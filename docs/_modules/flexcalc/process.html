<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>flexcalc.process &mdash; flexcalc  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            flexcalc
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">flexCALC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../flexcalc.html">Modules</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">flexcalc</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">flexcalc.process</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for flexcalc.process</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@author: Alex Kostenko</span>
<span class="sd">This module contains calculation routines for processing of the data.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Imports &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="k">as</span> <span class="nn">interp</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">SimpleITK</span> <span class="k">as</span> <span class="nn">sitk</span>

<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">registration</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">measure</span>
    
<span class="kn">from</span> <span class="nn">flexdata</span> <span class="kn">import</span> <span class="n">data</span>
<span class="kn">from</span> <span class="nn">flexdata</span> <span class="kn">import</span> <span class="n">display</span>
<span class="kn">from</span> <span class="nn">flexdata</span> <span class="kn">import</span> <span class="n">geometry</span> <span class="k">as</span> <span class="n">fdg</span>
<span class="kn">from</span> <span class="nn">flextomo</span> <span class="kn">import</span> <span class="n">projector</span>
<span class="kn">from</span> <span class="nn">flextomo</span> <span class="kn">import</span> <span class="n">model</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">analyze</span>

<span class="kn">from</span> <span class="nn">flexdata.data</span> <span class="kn">import</span> <span class="n">logger</span>

<span class="c1"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Methods &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<div class="viewcode-block" id="process_flex">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.process_flex">[docs]</a>
<span class="k">def</span> <span class="nf">process_flex</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sample</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memmap</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">proj_number</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">correct</span><span class="p">,</span> <span class="n">correct_vol_center</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read and process the array.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        path:  path to the flexray array</span>
<span class="sd">        sample:</span>
<span class="sd">        skip:</span>
<span class="sd">        memmap:</span>
<span class="sd">        index:</span>
<span class="sd">        proj_number (int): force projection number (treat lesser numbers as missing)</span>
<span class="sd">        </span>
<span class="sd">    Return:</span>
<span class="sd">        proj: min-log projections</span>
<span class="sd">        meta: meta array</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Read:    </span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reading...&#39;</span><span class="p">)</span>
    
    <span class="c1">#index = []</span>
    <span class="n">proj</span><span class="p">,</span> <span class="n">flat</span><span class="p">,</span> <span class="n">dark</span><span class="p">,</span> <span class="n">geom</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">read_flexray</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="p">,</span> <span class="n">skip</span> <span class="o">=</span> <span class="n">skip</span><span class="p">,</span> <span class="n">memmap</span> <span class="o">=</span> <span class="n">memmap</span><span class="p">,</span> <span class="n">proj_number</span> <span class="o">=</span> <span class="n">proj_number</span><span class="p">,</span> <span class="n">correct</span> <span class="o">=</span> <span class="n">correct</span><span class="p">,</span> <span class="n">correct_vol_center</span> <span class="o">=</span> <span class="n">correct_vol_center</span><span class="p">)</span>

    <span class="c1"># Prepro:            </span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">flat</span><span class="p">,</span> <span class="n">dark</span><span class="p">)</span>
<span class="w">        </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    index = numpy.array(index)</span>
<span class="sd">    index //= skip</span>
<span class="sd">    </span>
<span class="sd">    if (index[-1] + 1) != index.size:</span>
<span class="sd">        print(index.size)</span>
<span class="sd">        print(index[-1] + 1)</span>
<span class="sd">        print(&#39;Seemes like some files were corrupted or missing. We will try to correct thetas accordingly.&#39;)</span>
<span class="sd">        </span>
<span class="sd">        thetas = numpy.linspace(geom[&#39;range&#39;][0], geom[&#39;range&#39;][1], index[-1]+1)</span>
<span class="sd">        thetas = thetas[index]</span>
<span class="sd">        </span>
<span class="sd">        geom[&#39;thetas&#39;] = thetas</span>
<span class="sd">        </span>
<span class="sd">        import pylab</span>
<span class="sd">        pylab.plot(thetas, thetas ,&#39;*&#39;)</span>
<span class="sd">        pylab.title(&#39;Thetas&#39;)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">proj</span><span class="p">,</span> <span class="n">geom</span></div>

      
<div class="viewcode-block" id="preprocess">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.preprocess">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">flats</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">darks</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;sides&#39;</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Apply flatfield correction based on availability of flat- and dark-field.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        flats (ndarray): divide by flats</span>
<span class="sd">        darks (ndarray): subtract darks</span>
<span class="sd">        mode (str): &quot;sides&quot; to use maximum values of the detector sides to estimate the flat field or a mode of intensity distribution with &quot;single&quot;.     </span>
<span class="sd">        dim  (int): dimension that represents the projection number</span>
<span class="sd">    &#39;&#39;&#39;</span>          
    <span class="n">logger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Pre-processing...&#39;</span><span class="p">)</span>
    
    <span class="c1"># Cast to float if int:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;u&#39;</span><span class="p">):</span>    
            <span class="c1"># In case array is mapped on disk, we need to rewrite the file as another type:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>    
            <span class="n">array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rewrite_memmap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>    
            
    <span class="k">if</span> <span class="n">darks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">darks</span> <span class="o">=</span> <span class="n">darks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">darks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">darks</span> <span class="o">=</span> <span class="n">darks</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        
        <span class="c1"># Subtract:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">add_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="n">darks</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">darks</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">flats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">flats</span> <span class="o">=</span> <span class="n">flats</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">flats</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">flats</span> <span class="o">=</span> <span class="n">flats</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        
        <span class="c1"># Subtract:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">add_dim</span><span class="p">(</span><span class="n">flats</span><span class="p">,</span> <span class="o">-</span><span class="n">darks</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> 
        <span class="n">data</span><span class="o">.</span><span class="n">mult_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">flats</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        
    <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">array</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="c1"># Fix nans and infs after log:</span>
    <span class="n">array</span><span class="p">[</span><span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">return</span> <span class="n">array</span></div>


<div class="viewcode-block" id="residual_rings">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.residual_rings">[docs]</a>
<span class="k">def</span> <span class="nf">residual_rings</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Apply correction by computing outlayers .</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Compute mean image of intensity variations that are &lt; 5x5 pixels</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Our best agents are working on the case of the Residual Rings. This can take years if the kernel size is too big!&#39;</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;images&#39;</span><span class="p">):</span>                 
        
        <span class="n">block</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Compute:</span>
        <span class="n">tmp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">block</span> <span class="o">-</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">tmp</span> <span class="o">/=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">logger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Subtract residual rings.&#39;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;images&#39;</span><span class="p">):</span>                 
        
        <span class="n">block</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">block</span> <span class="o">-=</span> <span class="n">tmp</span>

        <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">block</span> 
    
    <span class="n">logger</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Residual ring correcion applied.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_stl">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.generate_stl">[docs]</a>
<span class="k">def</span> <span class="nf">generate_stl</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">geometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a mesh from a volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">stl</span> <span class="kn">import</span> <span class="n">mesh</span>

    <span class="c1"># Segment the volume:</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">array</span> <span class="o">&gt;</span> <span class="n">analyze</span><span class="o">.</span><span class="n">binary_threshold</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;otsu&#39;</span><span class="p">)</span>
    
    <span class="c1"># Close small holes:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Filling small holes...&#39;</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating mesh...&#39;</span><span class="p">)</span>
    <span class="c1"># Use marching cubes to obtain the surface mesh of these ellipsoids</span>
    <span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">marching_cubes_lewiner</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mesh with </span><span class="si">%1.1e</span><span class="s1"> vertices generated.&#39;</span> <span class="o">%</span> <span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># Create stl:    </span>
    <span class="n">stl_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="n">stl_mesh</span><span class="o">.</span><span class="n">vectors</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">faces</span><span class="p">]</span> <span class="o">*</span> <span class="n">geometry</span><span class="o">.</span><span class="n">voxel</span>
    
    <span class="k">return</span> <span class="n">stl_mesh</span></div>


<div class="viewcode-block" id="soft_threshold">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.soft_threshold">[docs]</a>
<span class="k">def</span> <span class="nf">soft_threshold</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes values smaller than the threshold value.</span>
<span class="sd">    Args:</span>
<span class="sd">        array (ndarray)  : data array (implicit)</span>
<span class="sd">        mode (str)       : &#39;histogram&#39;, &#39;otsu&#39; or &#39;constant&#39;</span>
<span class="sd">        threshold (float): threshold value if mode = &#39;constant&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Avoiding memory overflow:</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">binary_threshold</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        
        <span class="n">img</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">img</span><span class="p">[</span><span class="n">img</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">array</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">img</span></div>


<div class="viewcode-block" id="hard_threshold">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.hard_threshold">[docs]</a>
<span class="k">def</span> <span class="nf">hard_threshold</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a binary map based on the threshold value.</span>
<span class="sd">    Args:</span>
<span class="sd">        array (ndarray)  : data array (implicit)</span>
<span class="sd">        mode (str)       : &#39;histogram&#39;, &#39;otsu&#39; or &#39;constant&#39;</span>
<span class="sd">        threshold (float): threshold value if mode = &#39;constant&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Avoiding memory overflow:</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">binary_threshold</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    
    <span class="n">binary</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">binary</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">thresh</span></div>


<div class="viewcode-block" id="affine">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.affine">[docs]</a>
<span class="k">def</span> <span class="nf">affine</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply 3x3 rotation matrix and shift to a 3D arrayset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Applying affine transformation.&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>
    
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;Operations&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
   
    <span class="c1"># Compute offset:</span>
    <span class="n">T0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">T0</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">T0</span><span class="o">-</span><span class="n">T1</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>      
    
    <span class="k">return</span> <span class="n">array</span></div>

    
<div class="viewcode-block" id="scale">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.scale">[docs]</a>
<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Scales the volume via interpolation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Applying scaling.&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>
    
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;Operations&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
    
    <span class="n">array</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">zoom</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>
    
    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>      
    
    <span class="k">return</span> <span class="n">array</span>  </div>


<div class="viewcode-block" id="autocrop">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.autocrop">[docs]</a>
<span class="k">def</span> <span class="nf">autocrop</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">geom</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auto_crop the volume and update the geometry record.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        
    <span class="n">sz</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Old dimensions are: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sz</span><span class="p">))</span>
           
    <span class="n">array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">geom</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">geom</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">geom</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;New dimensions are: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">array</span></div>


<div class="viewcode-block" id="allign_moments">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.allign_moments">[docs]</a>
<span class="k">def</span> <span class="nf">allign_moments</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute orientations of the volume intensity moments and allign them with XYZ.</span>
<span class="sd">    Align the primary moment with vertical axis - use axis == 0.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Alligning volume moments.&#39;</span><span class="p">)</span>
    
    <span class="c1"># Moments orintations:</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">moments_orientation</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">R_90</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">R_90</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>    
        <span class="n">R_90</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">())</span>
  
    <span class="c1"># Apply transformation:</span>
    <span class="k">return</span> <span class="n">affine</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">R_90</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="rotate">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.rotate">[docs]</a>
<span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Rotates the volume via interpolation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Applying rotation.&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>    
    <span class="n">sz</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
       <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
       <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
       <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">angle</span> <span class="o">==</span> <span class="o">-</span><span class="mi">90</span><span class="p">:</span>
       <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
       <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
       <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span> 
        
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;slices&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">sz</span><span class="p">)</span> 
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>     
        
        <span class="n">sl</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">anyslice</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        
        <span class="n">array</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">angle</span><span class="p">,</span> <span class="n">reshape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">array</span></div>

        
<div class="viewcode-block" id="translate">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.translate">[docs]</a>
<span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a 3D tranlation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Applying translation.&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span>

    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;Operation&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
    
    <span class="c1">#ndimage.interpolation.shift(array, shift, output = array, order = order)</span>
    <span class="c1"># for some reason may return zeros in this implementation</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">)</span>    
    
    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">array</span></div>



<span class="k">def</span> <span class="nf">_itk2mat_</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform ITK to matrix and a translation vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># transform contains information about the centre of rptation, rotation and translation</span>
    <span class="c1"># We need to convert this to a rotation matrix and single translation vector</span>
    <span class="c1"># here we go,,,</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">GetParameters</span><span class="p">()[</span><span class="mi">3</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">euler</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">GetParameters</span><span class="p">()[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="n">euler</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    
    <span class="c1"># Centre of rotation:</span>
    <span class="n">centre</span> <span class="o">=</span> <span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">GetFixedParameters</span><span class="p">()[:</span><span class="mi">3</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">T0</span> <span class="o">=</span> <span class="n">centre</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="c1"># Add rotated vector pointing to the centre of rotation to total T</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="n">T0</span>
    
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">R</span>
    
<span class="k">def</span> <span class="nf">_mat2itk_</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize ITK transform from a rotation matrix and a translation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>       
    <span class="n">centre</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">euler</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Rotation</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="s1">&#39;zyx&#39;</span><span class="p">)</span>

    <span class="n">transform</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">Euler3DTransform</span><span class="p">()</span>
    <span class="n">transform</span><span class="o">.</span><span class="n">SetComputeZYX</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        
    <span class="n">transform</span><span class="o">.</span><span class="n">SetTranslation</span><span class="p">(</span><span class="o">-</span><span class="n">T</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">transform</span><span class="o">.</span><span class="n">SetCenter</span><span class="p">((</span><span class="n">centre</span> <span class="o">+</span> <span class="n">T</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>    

    <span class="n">transform</span><span class="o">.</span><span class="n">SetRotation</span><span class="p">(</span><span class="o">-</span><span class="n">euler</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">euler</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">euler</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>    
    
    <span class="k">return</span> <span class="n">transform</span>    
   
<span class="k">def</span> <span class="nf">_moments_registration_</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Register two volumes using image moments.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">        fixed (array): fixed 3D array</span>
<span class="sd">        moving (array): moving 3D array</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        moving will be altered in place.</span>
<span class="sd">        </span>
<span class="sd">        Ttot: translation vector</span>
<span class="sd">        Rtot: rotation matrix</span>
<span class="sd">        Tfix: position of the fixed volume</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Positions of the volumes:</span>
    <span class="n">Tfix</span><span class="p">,</span> <span class="n">Rfix</span>  <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">moments_orientation</span><span class="p">(</span><span class="n">fixed</span><span class="p">)</span>
    <span class="n">Tmov</span><span class="p">,</span> <span class="n">Rmov</span>  <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">moments_orientation</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
    
    <span class="c1"># Total rotation and shift:</span>
    <span class="n">Rtot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rmov</span><span class="p">,</span> <span class="n">Rfix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">Ttot</span> <span class="o">=</span> <span class="n">Tfix</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tmov</span><span class="p">,</span> <span class="n">Rtot</span><span class="p">)</span>

    <span class="c1"># Apply transformation:</span>
    <span class="n">moving_</span> <span class="o">=</span> <span class="n">affine</span><span class="p">(</span><span class="n">moving</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span><span class="p">)</span>
    
    <span class="c1"># Solve ambiguity with directions of intensity axes:    </span>
    <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span> <span class="o">=</span> <span class="n">_find_best_flip_</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving_</span><span class="p">,</span> <span class="n">Rfix</span><span class="p">,</span> <span class="n">Tfix</span><span class="p">,</span> <span class="n">Rmov</span><span class="p">,</span> <span class="n">Tmov</span><span class="p">,</span> <span class="n">use_CG</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">Ttot</span><span class="p">,</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">Tfix</span>
    
<span class="k">def</span> <span class="nf">_itk_registration_</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">,</span> <span class="n">R_init</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">T_init</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">smooth</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Carry out ITK based volume registration (based on Congugate Gradient).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fixed (array): fixed 3D array</span>
<span class="sd">        moving (array): moving 3D array</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        moving will be altered in place.</span>
<span class="sd">        </span>
<span class="sd">        T: translation vector</span>
<span class="sd">        R: rotation matrix</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#  Progress bar    </span>
    <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;Operations&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
    
    <span class="c1"># Initial transform:</span>
    <span class="k">if</span> <span class="n">R_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">R_init</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">R_init</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">R_init</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">R_init</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="k">if</span> <span class="n">T_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">T_init</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>    
    
    <span class="c1"># Initialize itk images:</span>
    <span class="n">fixed_image</span> <span class="o">=</span>  <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">fixed</span><span class="p">)</span>
    <span class="n">moving_image</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
    
    <span class="c1"># Regitration:</span>
    <span class="n">registration_method</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ImageRegistrationMethod</span><span class="p">()</span>

    <span class="c1"># Similarity metric settings.</span>
    <span class="c1">#registration_method.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)</span>
    <span class="n">registration_method</span><span class="o">.</span><span class="n">SetMetricSamplingStrategy</span><span class="p">(</span><span class="n">registration_method</span><span class="o">.</span><span class="n">RANDOM</span><span class="p">)</span>
    <span class="n">registration_method</span><span class="o">.</span><span class="n">SetMetricSamplingPercentage</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

    <span class="n">registration_method</span><span class="o">.</span><span class="n">SetInterpolator</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">sitkLinear</span><span class="p">)</span>

    <span class="c1"># Initial centering transform:</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">_mat2itk_</span><span class="p">(</span><span class="n">R_init</span><span class="p">,</span> <span class="n">T_init</span><span class="p">,</span> <span class="n">fixed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># Optimizer settings.</span>
    <span class="n">registration_method</span><span class="o">.</span><span class="n">SetOptimizerAsPowell</span><span class="p">()</span>
    <span class="c1">#registration_method.SetOptimizerAsGradientDescent(learningRate=0.5, numberOfIterations=200, convergenceMinimumValue=1e-10, convergenceWindowSize=10)</span>
    <span class="c1">#registration_method.SetOptimizerAsGradientDescentLineSearch(learningRate=1, numberOfIterations = 100)</span>
    <span class="c1">#registration_method.SetOptimizerAsConjugateGradientLineSearch(learningRate=1, numberOfIterations = 100)</span>
    <span class="c1">#registration_method.SetOptimizerScalesFromPhysicalShift()</span>

    <span class="c1"># Setup for the multi-resolution framework.            </span>
    <span class="n">registration_method</span><span class="o">.</span><span class="n">SetShrinkFactorsPerLevel</span><span class="p">(</span><span class="n">shrinkFactors</span> <span class="o">=</span> <span class="n">shrink</span><span class="p">)</span>
    <span class="n">registration_method</span><span class="o">.</span><span class="n">SetSmoothingSigmasPerLevel</span><span class="p">(</span><span class="n">smoothingSigmas</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">)</span>
    <span class="n">registration_method</span><span class="o">.</span><span class="n">SmoothingSigmasAreSpecifiedInPhysicalUnitsOn</span><span class="p">()</span>

    <span class="c1"># Don&#39;t optimize in-place, we would possibly like to run this cell multiple times.</span>
    <span class="n">registration_method</span><span class="o">.</span><span class="n">SetInitialTransform</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">inPlace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">transform</span> <span class="o">=</span> <span class="n">registration_method</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">Cast</span><span class="p">(</span><span class="n">fixed_image</span><span class="p">,</span> <span class="n">sitk</span><span class="o">.</span><span class="n">sitkFloat32</span><span class="p">),</span> 
                                                  <span class="n">sitk</span><span class="o">.</span><span class="n">Cast</span><span class="p">(</span><span class="n">moving_image</span><span class="p">,</span> <span class="n">sitk</span><span class="o">.</span><span class="n">sitkFloat32</span><span class="p">))</span>
    
    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1">#print(&quot;Final metric value: &quot;, registration_method.GetMetricValue())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimizer`s stopping condition: &quot;</span><span class="p">,</span> <span class="n">registration_method</span><span class="o">.</span><span class="n">GetOptimizerStopConditionDescription</span><span class="p">())</span>

    <span class="c1"># This is a bit of woodo to get to the same definition of Euler angles and translation that I use:</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">_itk2mat_</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">moving</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
    <span class="c1">#moving_image = sitk.Resample(moving_image, fixed_image, transform, sitk.sitkLinear, 0.0, moving_image.GetPixelID())</span>
    <span class="c1">#moving = sitk.GetArrayFromImage(moving_image)    </span>
        
    <span class="c1">#flexUtil.projection(fixed - moving, dim = 1, title = &#39;native diff&#39;)  </span>
    
    <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">registration_method</span><span class="o">.</span><span class="n">GetMetricValue</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_generate_flips_</span><span class="p">(</span><span class="n">Rfix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate number of rotation and translation vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># Rotate the moving object around it&#39;s main axes:</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),]</span>
    
    <span class="c1"># Axes:</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>    
        <span class="c1">#R.append(fdg._axangle2mat_(Rfix[ii], 180))</span>
        <span class="c1"># Angles:</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fdg</span><span class="o">.</span><span class="n">_axangle2mat_</span><span class="p">(</span><span class="n">Rfix</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="p">(</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">90.0</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">R</span>
                    
<div class="viewcode-block" id="register_volumes">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.register_volumes">[docs]</a>
<span class="k">def</span> <span class="nf">register_volumes</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">,</span> <span class="n">subsamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">use_moments</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_CG</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_flips</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="s1">&#39;otsu&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Registration of two 3D volumes.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fixed (array): reference volume</span>
<span class="sd">        moving (array): moving/slave volume</span>
<span class="sd">        subsamp (int): subsampling of the moments computation</span>
<span class="sd">        use_itk (bool): if True, use congugate descent method after aligning the moments</span>
<span class="sd">        treshold (str): can be None, &#39;otsu&#39; or &#39;histogram&#39; - defines the strategy for removing low intensity noise</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>        
    <span class="k">if</span> <span class="n">fixed</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">moving</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Fixed and moving volumes have different dimensions:&#39;</span><span class="p">,</span> <span class="n">fixed</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">moving</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Using image moments to register volumes.&#39;</span><span class="p">)</span>
        
    <span class="c1"># Subsample volumes:</span>
    <span class="n">fixed_0</span> <span class="o">=</span> <span class="n">fixed</span><span class="p">[::</span><span class="n">subsamp</span><span class="p">,::</span><span class="n">subsamp</span><span class="p">,::</span><span class="n">subsamp</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">moving_0</span> <span class="o">=</span> <span class="n">moving</span><span class="p">[::</span><span class="n">subsamp</span><span class="p">,::</span><span class="n">subsamp</span><span class="p">,::</span><span class="n">subsamp</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="c1"># We use Otsu here instead of binary_threshold to make sure that the same </span>
        <span class="c1"># threshold is applied to both images:</span>
        
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">threshold_otsu</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">moving_0</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">fixed_0</span><span class="p">[</span><span class="n">fixed_0</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">moving_0</span><span class="p">[</span><span class="n">moving_0</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="n">display</span><span class="o">.</span><span class="n">max_projection</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Preview: fixed volume&#39;</span><span class="p">)</span>
    <span class="n">display</span><span class="o">.</span><span class="n">max_projection</span><span class="p">(</span><span class="n">moving_0</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Preview: moving volume&#39;</span><span class="p">)</span>
        
    <span class="n">L2</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">fixed_0</span> <span class="o">-</span> <span class="n">moving_0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L2 norm before registration: </span><span class="si">%0.2e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">L2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">use_moments</span><span class="p">:</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running moments registration.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Progress:</span>
        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;Operations&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
    
        <span class="c1"># Positions of the volumes:</span>
        <span class="n">Tfix</span><span class="p">,</span> <span class="n">Rfix</span>  <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">moments_orientation</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">)</span>
        <span class="n">Tmov</span><span class="p">,</span> <span class="n">Rmov</span>  <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">moments_orientation</span><span class="p">(</span><span class="n">moving_0</span><span class="p">)</span>
               
        <span class="c1"># Total rotation and shift:</span>
        <span class="c1">#Rtot = numpy.dot(Rmov, Rfix.T)</span>
        <span class="c1">#Rtot = Rmov.T.dot(Rfix)</span>

        <span class="c1">#Ttot = Tfix - numpy.dot(Tmov, Rtot)</span>
        
        <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span> <span class="o">=</span> <span class="n">_find_best_flip_</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">,</span> <span class="n">moving_0</span><span class="p">,</span> <span class="n">Rfix</span><span class="p">,</span> <span class="n">Tfix</span><span class="p">,</span> <span class="n">Rmov</span><span class="p">,</span> <span class="n">Tmov</span><span class="p">,</span> <span class="n">use_CG</span> <span class="o">=</span> <span class="n">use_flips</span><span class="p">)</span>
        
        <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Initial transform:</span>
        <span class="n">Rtot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">Rtot</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Rtot</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Rtot</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># Positions of the volumes:</span>
        <span class="n">Tfix</span><span class="p">,</span> <span class="n">Rfix</span>  <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">moments_orientation</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">)</span>
        <span class="n">Tmov</span><span class="p">,</span> <span class="n">Rmov</span>  <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">moments_orientation</span><span class="p">(</span><span class="n">moving_0</span><span class="p">)</span>
        
        <span class="n">Ttot</span> <span class="o">=</span> <span class="n">Tfix</span> <span class="o">-</span> <span class="n">Tmov</span><span class="c1">#numpy.zeros(3)</span>
            
    <span class="c1"># Refine registration using ITK optimization:</span>
    <span class="k">if</span> <span class="n">use_CG</span><span class="p">:</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running ITK optimization.&#39;</span><span class="p">)</span>
        
        <span class="c1">#Rtot = Rmov.T.dot(Rfix)</span>
        <span class="c1">#Rtot = Rmov.dot(Rfix.T)</span>
        <span class="c1">#Ttot = Tfix - Tmov.dot(Rtot)</span>

        <span class="c1"># Find flip with or without CG:</span>
        <span class="c1">#Rtot, Ttot = _find_best_flip_(fixed_0, moving_0, Rfix, Tfix, Rmov, Tmov, use_CG = use_flips)</span>
        
        <span class="c1"># Show the result of moments registration:</span>
        <span class="n">L2</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">fixed_0</span> <span class="o">-</span> <span class="n">affine</span><span class="p">(</span><span class="n">moving_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L2 norm after moments registration: </span><span class="si">%0.2e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">L2</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>    
        
        <span class="c1"># Run CG with the best result:</span>
        <span class="n">Ttot</span><span class="p">,</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_itk_registration_</span><span class="p">(</span><span class="n">fixed_0</span><span class="p">,</span> <span class="n">moving_0</span><span class="p">,</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span><span class="p">,</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">smooth</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>               
            
    <span class="c1"># Apply transformation:</span>
    <span class="n">L2</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">fixed_0</span> <span class="o">-</span> <span class="n">affine</span><span class="p">(</span><span class="n">moving_0</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L2 norm after registration: </span><span class="si">%0.2e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">L2</span><span class="p">)</span>
            
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found shifts:&#39;</span><span class="p">,</span> <span class="n">Ttot</span> <span class="o">*</span> <span class="n">subsamp</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found Euler rotations:&#39;</span><span class="p">,</span> <span class="n">transforms3d</span><span class="o">.</span><span class="n">euler</span><span class="o">.</span><span class="n">mat2euler</span><span class="p">(</span><span class="n">Rtot</span><span class="p">))</span>        
    
    <span class="k">return</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span> <span class="o">*</span> <span class="n">subsamp</span> </div>

        
<div class="viewcode-block" id="register_astra_geometry">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.register_astra_geometry">[docs]</a>
<span class="k">def</span> <span class="nf">register_astra_geometry</span><span class="p">(</span><span class="n">proj_fix</span><span class="p">,</span> <span class="n">proj_mov</span><span class="p">,</span> <span class="n">geom_fix</span><span class="p">,</span> <span class="n">geom_mov</span><span class="p">,</span> <span class="n">subsamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a rigid transformation that makes sure that two reconstruction volumes are alligned.</span>
<span class="sd">    Args:</span>
<span class="sd">        proj_fix : projection data of the fixed volume</span>
<span class="sd">        proj_mov : projection data of the fixed volume</span>
<span class="sd">        geom_fix : projection data of the fixed volume</span>
<span class="sd">        geom_mov : projection data of the fixed volume</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        geom : geometry for the second reconstruction volume</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing a rigid tranformation between two datasets.&#39;</span><span class="p">)</span>
    
    <span class="c1"># Find maximum vol size:</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">proj_fix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">proj_mov</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    
    <span class="n">sz</span> <span class="o">+=</span> <span class="mi">10</span> <span class="c1"># for safety...</span>
    
    <span class="n">vol1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
    <span class="n">vol2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
    
    <span class="n">projector</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
    <span class="n">projector</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">subsets</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">projector</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sequential&#39;</span>
    
    <span class="n">projector</span><span class="o">.</span><span class="n">FDK</span><span class="p">(</span><span class="n">proj_fix</span><span class="p">,</span> <span class="n">vol1</span><span class="p">,</span> <span class="n">geom_fix</span><span class="p">)</span>    
    <span class="n">projector</span><span class="o">.</span><span class="n">SIRT</span><span class="p">(</span><span class="n">proj_fix</span><span class="p">,</span> <span class="n">vol1</span><span class="p">,</span> <span class="n">geom_fix</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
    
    <span class="n">projector</span><span class="o">.</span><span class="n">FDK</span><span class="p">(</span><span class="n">proj_mov</span><span class="p">,</span> <span class="n">vol2</span><span class="p">,</span> <span class="n">geom_mov</span><span class="p">)</span>
    <span class="n">projector</span><span class="o">.</span><span class="n">SIRT</span><span class="p">(</span><span class="n">proj_mov</span><span class="p">,</span> <span class="n">vol2</span><span class="p">,</span> <span class="n">geom_mov</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
    
    <span class="n">display</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">vol1</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Fixed volume preview&#39;</span><span class="p">)</span>
    <span class="n">display</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">vol1</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Moving volume preview&#39;</span><span class="p">)</span>
    
    <span class="c1"># Find transformation between two volumes:</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">register_volumes</span><span class="p">(</span><span class="n">vol1</span><span class="p">,</span> <span class="n">vol2</span><span class="p">,</span> <span class="n">subsamp</span> <span class="o">=</span> <span class="n">subsamp</span><span class="p">,</span> <span class="n">use_moments</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_CG</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">T</span></div>


<span class="k">def</span> <span class="nf">_find_best_flip_</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">,</span> <span class="n">Rfix</span><span class="p">,</span> <span class="n">Tfix</span><span class="p">,</span> <span class="n">Rmov</span><span class="p">,</span> <span class="n">Tmov</span><span class="p">,</span> <span class="n">use_CG</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sample</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the orientation of the moving volume with the mallest L2 distance from the fixed volume, </span>
<span class="sd">    given that there is 180 degrees amiguity for each of three axes.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fixed(array): 3D volume</span>
<span class="sd">        moving(array): 3D volume</span>
<span class="sd">        centre(array): corrdinates of the center of rotation</span>
<span class="sd">        area(int): radius around the center of rotation to look at</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        (array): rotation matrix corresponding to the best flip</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed</span><span class="p">[::</span><span class="n">sample</span><span class="p">,</span> <span class="p">::</span><span class="n">sample</span><span class="p">,</span> <span class="p">::</span><span class="n">sample</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
    <span class="n">moving</span> <span class="o">=</span> <span class="n">moving</span><span class="p">[::</span><span class="n">sample</span><span class="p">,</span> <span class="p">::</span><span class="n">sample</span><span class="p">,</span> <span class="p">::</span><span class="n">sample</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
    
    <span class="c1"># Apply filters to smooth erors somewhat:</span>
    <span class="n">fixed</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">moving</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Generate flips:</span>
    <span class="n">Rs</span> <span class="o">=</span> <span class="n">_generate_flips_</span><span class="p">(</span><span class="n">Rfix</span><span class="p">)</span>
    
    <span class="c1"># Compute L2 norms:</span>
    <span class="n">Lmax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
    
    <span class="c1"># Appliy flips:</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rs</span><span class="p">)):</span>
        
        <span class="n">Rtot_</span> <span class="o">=</span> <span class="n">Rmov</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rfix</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rs</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="n">Ttot_</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tfix</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tmov</span><span class="p">,</span> <span class="n">Rtot_</span><span class="p">))</span> <span class="o">/</span> <span class="n">sample</span>
        
        <span class="k">if</span> <span class="n">use_CG</span><span class="p">:</span>
            
            <span class="n">Ttot_</span><span class="p">,</span> <span class="n">Rtot_</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_itk_registration_</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">,</span> <span class="n">Rtot_</span><span class="p">,</span> <span class="n">Ttot_</span><span class="p">,</span> <span class="n">shrink</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,],</span> <span class="n">smooth</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,])</span> 
        
        <span class="n">mo_</span> <span class="o">=</span> <span class="n">affine</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">Rtot_</span><span class="p">,</span> <span class="n">Ttot_</span><span class="p">)</span>                  
    
        <span class="n">L</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">fixed</span> <span class="o">-</span> <span class="n">mo_</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">Lmax</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">:</span>
            <span class="n">Rtot</span> <span class="o">=</span> <span class="n">Rtot_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Ttot</span> <span class="o">=</span> <span class="n">Ttot_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Lmax</span> <span class="o">=</span> <span class="n">L</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We found better flip(</span><span class="si">%u</span><span class="s1">), L =&#39;</span><span class="o">%</span><span class="n">ii</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">display</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">fixed</span> <span class="o">-</span> <span class="n">mo_</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Diff (</span><span class="si">%u</span><span class="s1">). L2 = </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">Rtot</span><span class="p">,</span> <span class="n">Ttot</span> <span class="o">*</span> <span class="n">sample</span>
                
<div class="viewcode-block" id="equalize_intensity">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.equalize_intensity">[docs]</a>
<span class="k">def</span> <span class="nf">equalize_intensity</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;percentile&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute 99.99th percentile of two volumes and use it to renormalize the slave volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;percentile&#39;</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="mf">99.99</span><span class="p">)</span> 
        <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="mf">99.99</span><span class="p">)</span> 
        
        <span class="n">slave</span> <span class="o">*=</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;histogram&#39;</span><span class="p">:</span>
        
        <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">(</span><span class="n">master</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">intensity_range</span><span class="p">(</span><span class="n">slave</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="n">slave</span> <span class="o">*=</span> <span class="p">(</span><span class="n">c1</span> <span class="o">/</span> <span class="n">c2</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown mode:&#39;</span> <span class="o">+</span> <span class="n">mode</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="interpolate_lines">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.interpolate_lines">[docs]</a>
<span class="k">def</span> <span class="nf">interpolate_lines</span><span class="p">(</span><span class="n">proj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Interpolate values of the horizontal read out lines of the flexray flat panel detector.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">lines</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>    
    
    <span class="n">sz</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1536</span><span class="p">:</span>
        <span class="n">lines</span><span class="p">[</span><span class="mi">125</span><span class="p">::</span><span class="mi">256</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lines</span><span class="p">[</span><span class="mi">126</span><span class="p">::</span><span class="mi">256</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">//</span> <span class="mi">12</span>
        <span class="n">lines</span><span class="p">[(</span><span class="n">step</span><span class="o">-</span><span class="mi">1</span><span class="p">)::</span><span class="n">step</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>    

    <span class="n">interpolate_holes</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>   </div>

          
<div class="viewcode-block" id="interpolate_holes">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.interpolate_holes">[docs]</a>
<span class="k">def</span> <span class="nf">interpolate_holes</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mask2d</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Fill in the holes, for instance, saturated pixels.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        mask2d: holes are zeros. Mask is the same for all projections.</span>
<span class="sd">        kernel: size of the interpolation kernel</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mask_norm</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">mask2d</span><span class="p">),</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">)</span>
    <span class="c1">#flexUtil.slice(mask_norm, title = &#39;mask_norm&#39;)</span>
    
    <span class="n">sh</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;images&#39;</span><span class="p">):</span>    
            
        <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">mask2d</span>           

        <span class="c1"># Compute the filler:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">)</span> <span class="o">/</span> <span class="n">mask_norm</span>      
                                              
        <span class="c1">#flexUtil.slice(tmp, title = &#39;tmp&#39;)</span>

        <span class="c1"># Apply filler:                 </span>
        <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:][</span><span class="o">~</span><span class="n">mask2d</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="o">~</span><span class="n">mask2d</span><span class="p">]</span></div>

         
<div class="viewcode-block" id="interpolate_zeros">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.interpolate_zeros">[docs]</a>
<span class="k">def</span> <span class="nf">interpolate_zeros</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Fill in zero volues, for instance, blank pixels.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        kernel: Size of the interpolation kernel</span>
<span class="sd">        epsilon: if less than epsilon -&gt; interpolate</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;images&#39;</span><span class="p">):</span>    
           
        <span class="n">mask</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">epsilon</span> 
        <span class="n">mask_norm</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">)</span>
        
        <span class="c1"># Compute the filler:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">)</span> <span class="o">/</span> <span class="n">mask_norm</span>      
        
        <span class="c1"># Apply filler:                 </span>
        <span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>        </div>

        
<div class="viewcode-block" id="expand_medipix">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.expand_medipix">[docs]</a>
<span class="k">def</span> <span class="nf">expand_medipix</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get the correct image size for a MEDIPIX data (fill in extra central lines)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Bigger array:</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4</span>
    <span class="n">sz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">array</span><span class="p">[:</span> <span class="p">,</span><span class="n">ii</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">257</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">257</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">256</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">256</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">255</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">new</span><span class="p">[:</span> <span class="p">,</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">img</span>
        
    <span class="n">mask</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">interpolate_holes</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>        
        
    <span class="k">return</span> <span class="n">new</span>  </div>


<span class="k">def</span> <span class="nf">_parabolic_min_</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Use parabolic interpolation to find the extremum close to the index value:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="c1"># Compute parabolae:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>    
        <span class="n">y</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="n">denom</span>
            
        <span class="n">x0</span> <span class="o">=</span> <span class="o">-</span><span class="n">B</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">A</span>  
        
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">x0</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x0</span>    
    
<div class="viewcode-block" id="norm">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.norm">[docs]</a>
<span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;L2&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute L2 norm of the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">array</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>    </div>

    
<span class="k">def</span> <span class="nf">_sample_FDK_</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute a subsampled version of FDK</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">geometry_</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">projections_</span> <span class="o">=</span> <span class="n">projections</span><span class="p">[::</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">::</span><span class="n">sample</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">::</span><span class="n">sample</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    
    <span class="c1"># Apply subsampling to detector and volume:    </span>
    <span class="n">vol_sample</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sample</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">det_sample</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sample</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sample</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    
    <span class="n">geometry_</span><span class="p">[</span><span class="s1">&#39;vol_sample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vol_sample</span>
    <span class="n">geometry_</span><span class="p">[</span><span class="s1">&#39;det_sample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">det_sample</span>
    
    <span class="n">volume</span> <span class="o">=</span> <span class="n">projector</span><span class="o">.</span><span class="n">init_volume</span><span class="p">(</span><span class="n">projections_</span><span class="p">)</span>
    
    <span class="c1"># Do FDK without progress_bar:</span>
    <span class="n">projector</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">progress_bar</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">projector</span><span class="o">.</span><span class="n">FDK</span><span class="p">(</span><span class="n">projections_</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">geometry_</span><span class="p">)</span>
    <span class="n">projector</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">progress_bar</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">return</span> <span class="n">volume</span>
    
<span class="k">def</span> <span class="nf">_modifier_l2cost_</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">subsample</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;gradient&#39;</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Cost function based on L2 norm of the first derivative of the volume. Computation of the first derivative is done by FDK with pre-initialized reconstruction filter.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">geometry_</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">geometry_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">vol</span> <span class="o">=</span> <span class="n">_sample_FDK_</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry_</span><span class="p">,</span> <span class="n">subsample</span><span class="p">)</span>
    
    <span class="n">vol</span><span class="p">[</span><span class="n">vol</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Crop to central part:</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="p">[:,</span> <span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="o">-</span><span class="n">sz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="p">[</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="o">-</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="o">-</span><span class="n">sz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    
    <span class="c1">#vol /= vol.max()</span>

    <span class="n">l2</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;gradient&#39;</span><span class="p">:</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]))</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="p">(</span><span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>         
        
            <span class="n">l2</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">grad</span><span class="p">[</span><span class="n">grad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
            
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;highpass&#39;</span><span class="p">:</span>
        
            <span class="n">l2</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">vol</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;correlation&#39;</span><span class="p">:</span>
            
            <span class="n">im</span> <span class="o">=</span> <span class="n">vol</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">((</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">im</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">im</span><span class="p">)))</span>
            <span class="c1">#l2 += im[0,0]</span>
            <span class="n">l2</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">im</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">im</span><span class="p">)))</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown metric: &#39;</span> <span class="o">+</span> <span class="n">metric</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">preview</span><span class="p">:</span>
        <span class="n">display</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Guess = </span><span class="si">%0.2e</span><span class="s1">, L2 = </span><span class="si">%0.2e</span><span class="s1">&#39;</span><span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">l2</span><span class="p">))</span>    
            
    <span class="k">return</span> <span class="o">-</span><span class="n">l2</span>    
    
<div class="viewcode-block" id="optimize_modifier">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.optimize_modifier">[docs]</a>
<span class="k">def</span> <span class="nf">optimize_modifier</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">samp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;axs_tan&#39;</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>  
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Optimize a geometry modifier using a particular sampling of the projection array.</span>
<span class="sd">    &#39;&#39;&#39;</span>  
    <span class="n">maxiter</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span>
    
    <span class="c1"># Valuse of the objective function:</span>
    <span class="n">func_values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">maxiter</span><span class="p">)</span>    
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting a full search from: </span><span class="si">%0.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="s1">&#39;to </span><span class="si">%0.3f</span><span class="s1">&#39;</span><span class="o">%</span> <span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.3</span><span class="p">)</span> <span class="c1"># To print TQDM properly</span>
    
    <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;point&#39;</span><span class="p">):</span>
        
        <span class="n">func_values</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">_modifier_l2cost_</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">samp</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="n">preview</span><span class="p">)</span>
        
        <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>          
        
    <span class="n">min_index</span> <span class="o">=</span> <span class="n">func_values</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>    
    
    <span class="n">display</span><span class="o">.</span><span class="n">plot2d</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">func_values</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Objective: &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
    
    <span class="n">guess</span> <span class="o">=</span> <span class="n">_parabolic_min_</span><span class="p">(</span><span class="n">func_values</span><span class="p">,</span> <span class="n">min_index</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>  
    
    <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
        <span class="n">geometry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">guess</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimum found at </span><span class="si">%3.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">guess</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">guess</span></div>

        
<div class="viewcode-block" id="optimize_modifier_multires">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.optimize_modifier_multires">[docs]</a>
<span class="k">def</span> <span class="nf">optimize_modifier_multires</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">guess</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">subscale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;axs_tan&#39;</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>        
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The initial guess is </span><span class="si">%0.3f</span><span class="s1"> mm&#39;</span> <span class="o">%</span> <span class="n">guess</span><span class="p">)</span>
    
    <span class="c1"># Downscale the array:</span>
    <span class="k">while</span> <span class="n">subscale</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        
        <span class="c1"># Check that subscale is 1 or divisible by 2:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">subscale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">subscale</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">subscale</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Subscale factor should be a power of 2! Aborting...&#39;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Subscale factor </span><span class="si">%1d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">subscale</span><span class="p">)</span>    

        <span class="c1"># We will use constant subscale in the vertical direction but vary the horizontal subscale:</span>
        <span class="n">samp</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">5</span> <span class="o">*</span> <span class="n">subscale</span><span class="p">,</span> <span class="n">subscale</span><span class="p">,</span> <span class="n">subscale</span><span class="p">]</span>

        <span class="c1"># Create a search space of 5 values around the initial guess:</span>
        <span class="n">trial_values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">guess</span> <span class="o">-</span> <span class="n">step</span> <span class="o">*</span> <span class="n">subscale</span><span class="p">,</span> <span class="n">guess</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="n">subscale</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        
        <span class="n">guess</span> <span class="o">=</span> <span class="n">optimize_modifier</span><span class="p">(</span><span class="n">trial_values</span><span class="p">,</span> <span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">samp</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="n">preview</span><span class="p">,</span> <span class="n">update</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                
        <span class="n">subscale</span> <span class="o">=</span> <span class="n">subscale</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Old value:</span><span class="si">%0.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">geometry</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="s1">&#39;new value: </span><span class="si">%0.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">guess</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
        <span class="n">geometry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">guess</span>
    
    <span class="k">return</span> <span class="n">guess</span></div>


<div class="viewcode-block" id="optimize_rotation_center">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.optimize_rotation_center">[docs]</a>
<span class="k">def</span> <span class="nf">optimize_rotation_center</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">guess</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">subscale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">centre_of_mass</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;highpass&#39;</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find a center of rotation. If you can, use the center_of_mass option to get the initial guess.</span>
<span class="sd">    If that fails - use a subscale larger than the potential deviation from the center. Usually, 8 or 16 works fine!</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Usually a good initial guess is the center of mass of the projection array:</span>
    <span class="k">if</span>  <span class="n">guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  
        <span class="k">if</span> <span class="n">centre_of_mass</span><span class="p">:</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing centre of mass...&#39;</span><span class="p">)</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">centre</span><span class="p">(</span><span class="n">projections</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">geometry</span><span class="o">.</span><span class="n">voxel</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span>
        
            <span class="n">guess</span> <span class="o">=</span> <span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;axs_tan&#39;</span><span class="p">]</span>
        
    <span class="n">guess</span> <span class="o">=</span> <span class="n">optimize_modifier_multires</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">voxel</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">guess</span><span class="p">,</span> 
                                       <span class="n">subscale</span> <span class="o">=</span> <span class="n">subscale</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;axs_tan&#39;</span><span class="p">,</span> <span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="n">preview</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">guess</span></div>


<div class="viewcode-block" id="find_shift">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.find_shift">[docs]</a>
<span class="k">def</span> <span class="nf">find_shift</span><span class="p">(</span><span class="n">volume_m</span><span class="p">,</span> <span class="n">volume_s</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">volume_m</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">volume_s</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="c1"># Find intersection:</span>
    <span class="c1">#mask_m = binary_threshold(volume_m, mode = &#39;otsu&#39;)</span>
    <span class="c1">#mask_s = binary_threshold(volume_s, mode = &#39;otsu&#39;)</span>
    
    <span class="n">sect</span> <span class="o">=</span> <span class="n">volume_m</span><span class="p">[::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">volume_s</span><span class="p">[::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">sect</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING! Find shift fails bacause of no intersecting regions.&#39;</span><span class="p">)</span>
        
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">analyze</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">(</span><span class="n">sect</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">b</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">c</span> <span class="o">*=</span> <span class="mi">2</span>
    
    <span class="c1"># Compute cross-correlation:</span>
    <span class="n">vol_m</span> <span class="o">=</span> <span class="n">volume_m</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">vol_s</span> <span class="o">=</span> <span class="n">volume_s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    
    <span class="n">vol_m</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">laplace</span><span class="p">(</span><span class="n">vol_m</span><span class="p">)</span>
    <span class="n">vol_s</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">laplace</span><span class="p">(</span><span class="n">vol_s</span><span class="p">)</span>
    
    <span class="c1">#display.slice(vol_m, dim = 0, title = &#39;Master volume&#39;)</span>
    <span class="c1">#display.slice(vol_s, dim = 0, title = &#39;Slave volume&#39;)</span>
    
    <span class="c1">#display.slice(vol_m- vol_s, dim = 0, title = &#39;Diff before&#39;)</span>
    
    <span class="n">vol_m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">vol_m</span><span class="p">)</span>
    <span class="n">vol_m</span> <span class="o">=</span> <span class="o">-</span><span class="n">vol_m</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    
    <span class="n">vol_s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">vol_s</span><span class="p">)</span>
    
    <span class="n">vol_m</span> <span class="o">*=</span> <span class="n">vol_s</span>
    <span class="n">vol_m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">vol_m</span><span class="p">))</span>
    <span class="n">vol_m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">vol_m</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vol_m</span><span class="p">),</span> <span class="n">vol_m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol_m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        
    <span class="k">return</span> <span class="n">shift</span></div>


<span class="k">def</span> <span class="nf">_find_shift_</span><span class="p">(</span><span class="n">array_ref</span><span class="p">,</span> <span class="n">array_slave</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a small 2D shift between two 3d images.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">shifts</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Look at a few slices along the dimension dim:</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">array_slave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="mi">10</span><span class="p">):</span>
        
        <span class="c1"># Take a single slice:</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">anyslice</span><span class="p">(</span><span class="n">array_ref</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>    
        <span class="n">im_ref</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">array_ref</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">anyslice</span><span class="p">(</span><span class="n">array_slave</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>    
        <span class="n">im_slv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">array_slave</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Make sure that the array we compare is the same size:.        </span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Offset is too small!&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">im_slv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">im_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">|</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">im_slv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">im_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>            
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Offset is too large!&#39;</span><span class="p">)</span>
            
            <span class="c1"># TODO: make formula for smaller total size of the total array</span>
            
        <span class="n">im_ref</span> <span class="o">=</span> <span class="n">im_ref</span><span class="p">[</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">im_slv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">im_slv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            
        <span class="c1"># Find common area:        </span>
        <span class="n">no_zero</span> <span class="o">=</span> <span class="p">(</span><span class="n">im_ref</span> <span class="o">*</span> <span class="n">im_slv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">no_zero</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">im_ref</span> <span class="o">*=</span> <span class="n">no_zero</span>
            <span class="n">im_slv</span> <span class="o">*=</span> <span class="n">no_zero</span>
            
            <span class="c1"># Crop:</span>
            <span class="n">im_ref</span> <span class="o">=</span> <span class="n">im_ref</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">no_zero</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">no_zero</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">))]</span>    
            <span class="n">im_slv</span> <span class="o">=</span> <span class="n">im_slv</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">no_zero</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">no_zero</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">))]</span>                

            <span class="c1">#flexUtil.slice(im_ref - im_slv, title = &#39;im_ref&#39;)</span>
                                  
            <span class="c1"># Laplace is way better for clipped objects than comparing intensities!</span>
            <span class="n">im_ref</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">laplace</span><span class="p">(</span><span class="n">im_ref</span><span class="p">)</span>
            <span class="n">im_slv</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">laplace</span><span class="p">(</span><span class="n">im_slv</span><span class="p">)</span>
            
            <span class="c1">#display.slice(im_ref, title = &#39;im_ref&#39;)</span>
            <span class="c1">#display.slice(im_slv, title = &#39;im_slv&#39;)</span>
        
            <span class="c1"># Shift registration with subpixel accuracy (skimage):</span>
            <span class="n">shift</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">diffphase</span> <span class="o">=</span> <span class="n">registration</span><span class="o">.</span><span class="n">phase_cross_correlation</span><span class="p">(</span><span class="n">im_ref</span><span class="p">,</span> <span class="n">im_slv</span><span class="p">,</span> <span class="n">upsample_factor</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                        
            <span class="n">shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>

    <span class="n">shifts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span>            
    
    <span class="k">if</span> <span class="n">shifts</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>        
        <span class="n">shift</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># prune around mean:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>    
        
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifts</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        
        <span class="n">error</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">error</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">shifts</span><span class="p">[</span><span class="n">error</span> <span class="o">&lt;</span> <span class="n">mean</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">shifts</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="n">shift</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            
        <span class="k">else</span><span class="p">:</span>
            
            <span class="c1"># total:        </span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>    
            <span class="n">std</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="n">shift_norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">std_norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">std</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found shift:&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="s1">&#39;with STD:&#39;</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>
            
            <span class="c1"># Check that std is at least 2 times less than the shift estimate:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">std_norm</span> <span class="o">&gt;</span> <span class="n">shift_norm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">shift_norm</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>    
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bad shift. Discarding it.&#39;</span><span class="p">)</span>
                    <span class="n">shift</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                
    <span class="k">return</span> <span class="n">shift</span> 

<span class="k">def</span> <span class="nf">_append_</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">x_offset</span><span class="p">,</span> <span class="n">y_offset</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">,</span> <span class="n">base_dist</span><span class="p">,</span> <span class="n">new_dist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append a new image to total via interpolation:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Pad to match sizes:</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">)),</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>  
    
    <span class="c1"># Apply shift:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>   
        
        <span class="c1"># Shift image:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="p">[</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">x_offset</span><span class="p">],</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Create distances to edge:</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">base_dist</span> <span class="o">*</span> <span class="n">total</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_dist</span> <span class="o">*</span> <span class="n">new</span><span class="p">))</span> <span class="o">/</span> <span class="n">norm</span>
    
<div class="viewcode-block" id="append_tile">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.append_tile">[docs]</a>
<span class="k">def</span> <span class="nf">append_tile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">tot_array</span><span class="p">,</span> <span class="n">tot_geom</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append a tile to a larger arrayset.</span>
<span class="sd">    Args:</span>
<span class="sd">        </span>
<span class="sd">        array: projection stack</span>
<span class="sd">        geom: geometry descritption</span>
<span class="sd">        tot_array: output array</span>
<span class="sd">        tot_geom: output geometry</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span> 
        
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Stitching a tile...&#39;</span><span class="p">)</span>               
    
    <span class="c1"># Assuming all projections have equal number of angles and same pixel sizes</span>
    <span class="n">total_shape</span> <span class="o">=</span> <span class="n">tot_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">det_shape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tot_geom</span><span class="p">[</span><span class="s1">&#39;det_pixel&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">geom</span><span class="p">[</span><span class="s1">&#39;det_pixel&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;This array has different detector pixels! </span><span class="si">%f</span><span class="s1"> v.s. </span><span class="si">%f</span><span class="s1">. Aborting!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="s1">&#39;det_pixel&#39;</span><span class="p">],</span> <span class="n">tot_geom</span><span class="p">[</span><span class="s1">&#39;det_pixel&#39;</span><span class="p">]))</span>
    
    <span class="k">if</span> <span class="n">tot_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;This array has different number of projections from the others. </span><span class="si">%u</span><span class="s1"> v.s. </span><span class="si">%u</span><span class="s1">. Aborting!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tot_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="n">total_size</span> <span class="o">=</span> <span class="n">tot_geom</span><span class="o">.</span><span class="n">detector_size</span><span class="p">(</span><span class="n">total_shape</span><span class="p">)</span>
    <span class="n">det_size</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">detector_size</span><span class="p">(</span><span class="n">det_shape</span><span class="p">)</span>
                    
    <span class="c1"># Offset from the left top corner:</span>
    <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">tot_geom</span><span class="o">.</span><span class="n">detector_centre</span><span class="p">()</span>   
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">detector_centre</span><span class="p">()</span>
    
    <span class="n">x_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">+</span> <span class="n">total_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">det_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">geom</span><span class="o">.</span><span class="n">pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y_offset</span> <span class="o">=</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">+</span> <span class="n">total_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">det_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">geom</span><span class="o">.</span><span class="n">pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Round em up!            </span>
    <span class="n">x_offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x_offset</span><span class="p">))</span>                   
    <span class="n">y_offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y_offset</span><span class="p">))</span>                   
                
    <span class="c1"># Pad image to get the same size as the total_slice:        </span>
    <span class="n">pad_x</span> <span class="o">=</span> <span class="n">tot_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">pad_y</span> <span class="o">=</span> <span class="n">tot_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
    
    <span class="c1"># Collapce both arraysets and compute residual shift</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">_find_shift_</span><span class="p">(</span><span class="n">tot_array</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="p">[</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">x_offset</span><span class="p">])</span>
    
    <span class="n">x_offset</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y_offset</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
           
    <span class="c1"># Precompute weights:</span>
    <span class="n">base0</span> <span class="o">=</span> <span class="p">(</span><span class="n">tot_array</span><span class="p">[:,</span> <span class="p">::</span><span class="mi">100</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
    
    <span class="n">new0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">base0</span><span class="p">)</span>
    <span class="c1"># Shift image:</span>
    <span class="n">new0</span><span class="p">[:</span><span class="n">det_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">det_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">new0</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">new0</span><span class="p">,</span> <span class="p">[</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">x_offset</span><span class="p">],</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">#new0[y_offset:int(y_offset+det_shape[0]), x_offset:int(x_offset + det_shape[1])] = 1.0</span>
    
    <span class="n">base_dist</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">distance_transform_bf</span><span class="p">(</span><span class="n">base0</span><span class="p">)</span>    
    <span class="n">new_dist</span> <span class="o">=</span>  <span class="n">ndimage</span><span class="o">.</span><span class="n">distance_transform_bf</span><span class="p">(</span><span class="n">new0</span><span class="p">)</span>    
     
    <span class="c1"># Trim edges to avoid interpolation errors:</span>
    <span class="n">base_dist</span> <span class="o">-=</span> <span class="mi">1</span>    
    <span class="n">new_dist</span> <span class="o">-=</span> <span class="mi">1</span>
    
    <span class="n">base_dist</span> <span class="o">*=</span> <span class="n">base_dist</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">new_dist</span> <span class="o">*=</span> <span class="n">new_dist</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">base_dist</span> <span class="o">+</span> <span class="n">new_dist</span><span class="p">)</span>
    <span class="n">norm</span><span class="p">[</span><span class="n">norm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
    
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    
    <span class="c1"># Apply offsets:</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">tot_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;img&#39;</span><span class="p">):</span>   
        
        <span class="c1"># Pad to match sizes:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:],</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">)),</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>  
        
        <span class="c1"># Apply shift:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>   
            
            <span class="c1"># Shift image:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="p">[</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">x_offset</span><span class="p">],</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                    
        <span class="c1"># Add two images in a smart way:</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">tot_array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span>  
        
        <span class="c1"># Create distances to edge:</span>
        <span class="n">tot_array</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">base_dist</span> <span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_dist</span> <span class="o">*</span> <span class="n">new</span><span class="p">))</span> <span class="o">/</span> <span class="n">norm</span></div>

        
<div class="viewcode-block" id="append_volume">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.append_volume">[docs]</a>
<span class="k">def</span> <span class="nf">append_volume</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">tot_array</span><span class="p">,</span> <span class="n">tot_geom</span><span class="p">,</span> <span class="n">ramp</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append a volume array to a larger arrayset.</span>
<span class="sd">    Args:</span>
<span class="sd">        </span>
<span class="sd">        array: projection stack</span>
<span class="sd">        geom: geometry descritption</span>
<span class="sd">        tot_array: output array</span>
<span class="sd">        tot_geom: output geometry</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Stitching a volume block...&#39;</span><span class="p">)</span>               
    
    <span class="n">display</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Append&#39;</span><span class="p">)</span>
    <span class="n">display</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">tot_array</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Total&#39;</span><span class="p">)</span>
    
    <span class="c1"># Offset (pixel precision):   </span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="s1">&#39;vol_tra&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">geom</span><span class="p">[</span><span class="s1">&#39;img_pixel&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">offset</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tot_geom</span><span class="p">[</span><span class="s1">&#39;vol_tra&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">tot_geom</span><span class="p">[</span><span class="s1">&#39;img_pixel&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tot_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    
    <span class="c1"># Create a slice of the big arrayset:</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="c1"># Writable view on the total array:</span>
    <span class="n">w_array</span> <span class="o">=</span> <span class="n">tot_array</span><span class="p">[</span><span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span>
    
    <span class="c1"># Find shift:</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">find_shift</span><span class="p">(</span><span class="n">w_array</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found shift of :&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">array</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>   
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing weigths.&#39;</span><span class="p">)</span>
    <span class="c1"># Ramp weight:</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float16&#39;</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ramp</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">ramp</span><span class="p">,</span> <span class="n">ramp</span><span class="p">],</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ramp</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">ramp</span><span class="p">,</span> <span class="n">ramp</span><span class="p">],</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ramp</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">ramp</span><span class="p">,</span> <span class="n">ramp</span><span class="p">],</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    
    <span class="c1"># Weight can be 100% where no prior array exists:</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">weight</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">w_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Adding volumes.&#39;</span><span class="p">)</span>
    <span class="c1"># Apply weights and add (save memory):</span>
    <span class="n">array</span> <span class="o">*=</span> <span class="n">weight</span>
    
    <span class="n">weight</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">weight</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="n">w_array</span> <span class="o">*=</span> <span class="n">weight</span>
    <span class="n">w_array</span> <span class="o">+=</span> <span class="n">array</span>                   
    
    <span class="n">display</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">tot_array</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Total&#39;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="equivalent_density">
<a class="viewcode-back" href="../../flexcalc.html#flexcalc.process.equivalent_density">[docs]</a>
<span class="k">def</span> <span class="nf">equivalent_density</span><span class="p">(</span><span class="n">projections</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">spectr</span><span class="p">,</span> <span class="n">compound</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">preview</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Transfrom intensity values to projected density for a single material array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Assuming that we have log array!</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating the transfer function.&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">preview</span><span class="p">:</span>
        <span class="n">display</span><span class="o">.</span><span class="n">plot2d</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">spectr</span><span class="p">,</span> <span class="n">semilogy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Spectrum&#39;</span><span class="p">)</span>
    
    <span class="c1"># Attenuation of 1 mm:</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">linear_attenuation</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">compound</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span>
    
    <span class="c1"># Make thickness range that is sufficient for interpolation:</span>
    <span class="c1">#m = (geometry[&#39;src2obj&#39;] + geometry[&#39;det2obj&#39;]) / geometry[&#39;src2obj&#39;]</span>
    <span class="c1">#img_pix = geometry[&#39;det_pixel&#39;] / m</span>
    <span class="n">img_pix</span> <span class="o">=</span> <span class="n">geometry</span><span class="p">[</span><span class="s1">&#39;img_pixel&#39;</span><span class="p">]</span>

    <span class="n">thickness_min</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">thickness_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">projections</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">img_pix</span> <span class="o">*</span> <span class="mi">2</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assuming thickness range:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">thickness_min</span><span class="p">,</span> <span class="n">thickness_max</span><span class="p">])</span>
    <span class="n">thickness</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">thickness_min</span><span class="p">,</span> <span class="n">thickness_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">projections</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    
    <span class="n">exp_matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">thickness</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>
        
    <span class="n">synth_counts</span> <span class="o">=</span> <span class="n">exp_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">spectr</span><span class="p">)</span>
    
    <span class="c1">#flexUtil.plot(thickness, title = &#39;thickness&#39;)</span>
    <span class="c1">#flexUtil.plot(mu, title = &#39;mu&#39;)</span>
    <span class="c1">#flexUtil.plot(synth_counts, title = &#39;synth_counts&#39;)</span>
    
    <span class="k">if</span> <span class="n">preview</span><span class="p">:</span>
        <span class="n">display</span><span class="o">.</span><span class="n">plot2d</span><span class="p">(</span><span class="n">thickness</span><span class="p">,</span><span class="n">synth_counts</span><span class="p">,</span> <span class="n">semilogy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Attenuation v.s. thickness [mm].&#39;</span><span class="p">)</span>
        
    <span class="n">synth_counts</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">synth_counts</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Callibration attenuation range:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">synth_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">synth_counts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;array attenuation range:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">projections</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">projections</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Applying transfer function.&#39;</span><span class="p">)</span>    
    
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1"># Give time to print messages before the progress is created</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">projections</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;img&#39;</span><span class="p">):</span>
        
        <span class="n">projections</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">projections</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="p">:],</span> <span class="n">synth_counts</span><span class="p">,</span> <span class="n">thickness</span> <span class="o">*</span> <span class="n">density</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span> 
               
    <span class="k">return</span> <span class="n">projections</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Author.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>